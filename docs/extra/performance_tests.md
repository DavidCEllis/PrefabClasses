# Performance test results #

These tests compare prefab_classes with other modules that, as at least part of their
feature set, handle writing class boilerplate. Some of these modules may have more
features or do extra work which could make them more useful in certain situations.

The main modules being compared are prefab_classes, dataclasses, attrs and pydantic.
Some tests are also run against `namedtuple` and `NamedTuple` along with handwritten
classes.

Tests are run on 2 different machines. They're not perfectly stable performance tests
but they give some sense of the relative speeds. (I'd love to have more stability in 
the tests but that's not something I have experience in).

Rough specs:
```
XPS 13 9360 Laptop: Ubuntu 20.04 / Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz / 16 GB 1867MHz LPDDR3
2018 Macbook: MacOS 12.6 / 2.3 GHz Quad-Core Intel Core i5 / 8 GB 2133 MHz LPDDR3
```

## Hyperfine tests ##

These tests are run using [Hyperfine](https://github.com/sharkdp/hyperfine)

The shell scripts to run these tests can be generated by running 
`perf/hyperfine_testmaker.py`.

### Import Time ###

This just tests the overall time to launch python and import the module to be used 
for constructing classes. `python -c "pass"` used as a baseline.

`collections` is imported for `namedtuple` and `typing` is imported for `NamedTuple`.

The base launch time for python on the Macbook seemed to be significantly slower while
subsequent import times were not affected as heavily. This makes the relative
scaling significantly different between the two machines.

#### XPS 13 ####

```
Python 3.11.1 (main, Dec 22 2022, 12:04:25) [GCC 9.4.0]
attrs 22.2.0
pydantic 1.10.2
prefab_classes v0.9.1
```

| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| `python -c "pass"` | 11.3 ± 0.2 | 11.0 | 12.0 | 1.00 |
| `python -c "import collections"` | 13.3 ± 0.2 | 13.0 | 14.0 | 1.18 ± 0.03 |
| `python -c "import typing"` | 22.7 ± 0.6 | 22.1 | 25.9 | 2.01 ± 0.07 |
| `python -c "import dataclasses"` | 30.2 ± 0.6 | 29.2 | 32.7 | 2.67 ± 0.07 |
| `python -c "import attrs"` | 48.4 ± 0.8 | 47.4 | 51.8 | 4.28 ± 0.11 |
| `python -c "import pydantic"` | 75.3 ± 0.9 | 74.2 | 78.6 | 6.66 ± 0.16 |
| `python -c "import prefab_classes"` | 13.1 ± 0.2 | 12.8 | 13.6 | 1.16 ± 0.03 |


#### Macbook ####

```
Python 3.11.1 (main, Dec  7 2022, 05:32:48) [Clang 13.0.0 (clang-1300.0.29.30)]
attrs 22.2.0
pydantic 1.10.2
prefab_classes v0.9.1
```

| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| `python -c "pass"` | 25.5 ± 1.4 | 23.6 | 31.8 | 1.00 |
| `python -c "import collections"` | 27.4 ± 0.8 | 25.8 | 30.3 | 1.07 ± 0.07 |
| `python -c "import typing"` | 37.6 ± 0.6 | 36.3 | 39.6 | 1.47 ± 0.08 |
| `python -c "import dataclasses"` | 45.3 ± 1.1 | 43.7 | 50.7 | 1.78 ± 0.11 |
| `python -c "import attrs"` | 63.7 ± 1.0 | 62.0 | 67.2 | 2.49 ± 0.14 |
| `python -c "import pydantic"` | 98.3 ± 2.4 | 94.3 | 111.0 | 3.85 ± 0.23 |
| `python -c "import prefab_classes"` | 27.0 ± 1.0 | 25.3 | 32.3 | 1.06 ± 0.07 |


### Class Contruction ###

This is a series of tests of the time it takes to launch python and generate 100
classes each with 5 attributes.

The code for each class looks roughly like this:

```python
@dataclass
class C0:
    a: int
    b: int
    c: int
    d: int
    e: int
```

In some cases the `__init__`, `__repr__` and `__eq__` functions are also looked up
in order to force them to be generated (prefab_eval).

For a baseline comparison, `python -c "pass"` is included just to show the overhead
from the interpreter.

As `prefab_classes` has multiple ways of generating classes it is here multiple times.

`prefab_classes_timer` generates the classes dynamically, but leaves the methods 
unused so they are not yet evaluated. This is how they would usually be on import.

`prefab_eval_timer` generates the classes dynamically, and also generates their 
methods as they would be after first use.

`compiled_prefab_timer` uses compiled classes in the .pyc files via the import
hook. This has some overhead from hashed .pyc validation and additional imports.

`precompiled_prefab_timer` uses classes that have been rewritten out to .py and so
should be the same speed as regular python classes, as that's what they are.

#### XPS13 ####

```
Python 3.11.1 (main, Dec 22 2022, 12:04:25) [GCC 9.4.0]
attrs 22.2.0
pydantic 1.10.2
prefab_classes v0.9.1
```

| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| `python -c "pass"` | 11.3 ± 0.3 | 11.0 | 12.2 | 1.00 |
| `python hyperfine_importers/native_classes_timer.py` | 13.1 ± 0.3 | 12.8 | 14.0 | 1.16 ± 0.03 |
| `python hyperfine_importers/namedtuples_timer.py` | 21.5 ± 0.5 | 21.1 | 24.3 | 1.91 ± 0.06 |
| `python hyperfine_importers/typed_namedtuples_timer.py` | 35.4 ± 0.5 | 34.6 | 38.5 | 3.13 ± 0.08 |
| `python hyperfine_importers/dataclasses_timer.py` | 73.4 ± 0.8 | 72.4 | 76.5 | 6.50 ± 0.16 |
| `python hyperfine_importers/attrs_timer.py` | 119.9 ± 1.7 | 117.8 | 126.3 | 10.62 ± 0.28 |
| `python hyperfine_importers/pydantic_timer.py` | 136.6 ± 1.9 | 134.6 | 149.3 | 12.10 ± 0.32 |
| `python hyperfine_importers/prefab_classes_timer.py` | 17.2 ± 0.5 | 16.8 | 19.7 | 1.52 ± 0.06 |
| `python hyperfine_importers/prefab_eval_timer.py` | 42.9 ± 0.9 | 41.8 | 48.2 | 3.80 ± 0.12 |
| `python hyperfine_importers/compiled_prefab_timer.py` | 14.0 ± 0.3 | 13.6 | 15.2 | 1.24 ± 0.04 |
| `python hyperfine_importers/precompiled_prefab_timer.py` | 13.3 ± 0.3 | 12.9 | 15.4 | 1.18 ± 0.04 |


#### Macbook ####

```
Python 3.11.1 (main, Dec  7 2022, 05:32:48) [Clang 13.0.0 (clang-1300.0.29.30)]
attrs 22.2.0
pydantic 1.10.2
prefab_classes v0.7.8a1
```

| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| `python -c "pass"` | 25.4 ± 1.1 | 23.6 | 28.4 | 1.00 |
| `python hyperfine_importers/native_classes_timer.py` | 27.0 ± 0.7 | 25.7 | 29.5 | 1.06 ± 0.05 |
| `python hyperfine_importers/namedtuples_timer.py` | 35.6 ± 1.4 | 33.2 | 42.2 | 1.40 ± 0.08 |
| `python hyperfine_importers/typed_namedtuples_timer.py` | 49.4 ± 1.6 | 47.0 | 57.6 | 1.95 ± 0.10 |
| `python hyperfine_importers/dataclasses_timer.py` | 84.7 ± 0.9 | 83.0 | 87.7 | 3.34 ± 0.15 |
| `python hyperfine_importers/attrs_timer.py` | 127.7 ± 1.4 | 125.4 | 134.9 | 5.03 ± 0.22 |
| `python hyperfine_importers/pydantic_timer.py` | 147.5 ± 2.8 | 143.6 | 160.9 | 5.82 ± 0.27 |
| `python hyperfine_importers/prefab_classes_timer.py` | 31.0 ± 0.9 | 29.2 | 35.0 | 1.22 ± 0.06 |
| `python hyperfine_importers/prefab_eval_timer.py` | 53.8 ± 1.0 | 51.7 | 55.7 | 2.12 ± 0.10 |
| `python hyperfine_importers/compiled_prefab_timer.py` | 27.9 ± 0.7 | 26.4 | 29.7 | 1.10 ± 0.05 |
| `python hyperfine_importers/precompiled_prefab_timer.py` | 27.2 ± 0.8 | 25.4 | 30.4 | 1.07 ± 0.06 |


## json tests ##

Based on the ORJSON dataclasses performance test (but without using orjson).

Initially the to_json function was slower than creating a new encoder using as_dict,
the funcs module has been modified to make to_json faster. 

Pydantic's conversion just uses its `.json()` method with no arguments. I'm not sure
why this is slow, but I assume there is a faster method if you're more familiar
with Pydantic.

The `dataclasses_naive` method is simply calling `asdict` on the main object before
serialization, the `dataclasses_cache` method is essentially the `prefab_as_dict`
function written specifically for dataclasses.

`cattrs` conversion is consistently slightly faster. It is a more comprehensive serialization
module 

Result from `perf/serialization/json_conversion_speed.py`

```
Python Version: 3.11.1 (main, Dec  7 2022, 05:32:48) [Clang 13.0.0 (clang-1300.0.29.30)]
Prefab Classes version: v0.8.4a1
Platform: macOS-12.6-x86_64-i386-64bit
```

| Method            | Time /s |
|-------------------|---------|
| prefab_as_dict    |     1.4 |
| prefab_to_json    |     1.4 |
| dataclasses_naive |     4.7 |
| dataclasses_cache |     1.4 |
| attrs_asdict      |     3.4 |
| cattrs            |     1.3 |
| pydantic          |     9.2 |


## perf_profile.py ##

This is **NOT** an overall performance test. This is just intended to check - 
very roughly - how quickly a module with a large number of generated classes 
will import.

These test results do not include the time for the initial .pyc compilation of the
test file.

These tests are just run on the 2018 Macbook Pro I've been using for development:
2.3 GHz Quad-Core Intel Core i5 / 8 GB 2133 MHz LPDDR3

### v0.7.7 ###

```
Python Version: 3.11.1 (main, Dec  7 2022, 05:32:48) [Clang 13.0.0 (clang-1300.0.29.30)]
Prefab Classes version: v0.7.7
Platform: macOS-12.6-x86_64-i386-64bit
Initial compilation time EXCLUDED
Time for 100 imports of 100 classes defined with 5 basic attributes
```

| Method | Total Time (seconds) |
| --- | --- |
| standard classes | 0.15 |
| namedtuple | 0.76 |
| NamedTuple | 1.25 |
| dataclasses | 3.91 |
| attrs 22.2.0 | 6.40 |
| pydantic 1.10.2 | 5.22 |
| dabeaz/cluegen | 0.17 |
| dabeaz/cluegen_eval | 2.01 |
| dabeaz/dataklasses | 0.19 |
| dabeaz/dataklasses_eval | 0.22 |
| prefab v0.7.7 | 0.33 |
| prefab_attributes v0.7.7 | 0.32 |
| prefab_eval v0.7.7 | 2.59 |
| compiled_prefab v0.7.7 | 0.16 |
| compiled_prefab_nocache v0.7.7 | 7.81 |


### v0.7.5a4 ###

```
Python Version: 3.11.0 (main, Oct 26 2022, 01:05:56) [Clang 13.0.0 (clang-1300.0.29.30)]
Prefab Classes version: v0.7.5a4
Platform: macOS-12.6-x86_64-i386-64bit
Initial compilation time EXCLUDED
Time for 100 imports of 100 classes defined with 5 basic attributes
```

| Method | Total Time (seconds) |
| --- | --- |
| standard classes | 0.15 |
| namedtuple | 0.71 |
| NamedTuple | 1.22 |
| dataclasses | 4.13 |
| attrs 22.1.0 | 6.25 |
| pydantic 1.10.2 | 5.50 |
| dabeaz/cluegen | 0.18 |
| dabeaz/cluegen_eval | 2.19 |
| dabeaz/dataklasses | 0.21 |
| dabeaz/dataklasses_eval | 0.20 |
| prefab v0.7.5a4 | 0.35 |
| prefab_attributes v0.7.5a4 | 0.36 |
| prefab_eval v0.7.5a4 | 2.69 |
| compiled_prefab v0.7.5a4 | 0.16 |
| compiled_prefab_nocache v0.7.5a4 | 8.16 |
